271-D

ポイント
この問題は典型的なナップザック問題である。dp[][]でもしその和が取れるならTrueにして進めていく。
全部の探索が終わったら今度は逆に探索を初めて、trueのところをたどっていけばよい。

#include<iostream>
#include<vector>
using namespace std;
int main(){
  int n,s;
  cin>>n>>s;
  vector<int> a(n),b(n);
  for(int i=0;i<n;i++) cin>>a[i]>>b[i];
  vector<vector<bool>> dp(n+1,vector<bool>(s+1,false));
  dp[0][0]=true;
  for(int i=0;i<n;i++){
    for(int j=0;j<=s;j++){
      if(j-a[i]>=0&&dp[i][j-a[i]]==true) dp[i+1][j]=true;
      if(j-b[i]>=0&&dp[i][j-b[i]]==true) dp[i+1][j]=true;
    }
  }
  if(dp[n][s]==false) cout<<"No"; 
  else{
    cout<<"Yes"<<endl;
    vector<char> t;
    int tmp=s;
    for(int i=n;i>0;i--){
      if(tmp-a[i-1]>=0&&dp[i-1][tmp-a[i-1]]==true){
        t.push_back('H');
        tmp-=a[i-1];
      }
      else if(tmp-b[i-1]>=0&&dp[i-1][tmp-b[i-1]]==true){
        t.push_back('T');
        tmp-=b[i-1];
      }
    }
    for(int i=(int)t.size()-1;i>=0;i--) cout<<t[i];
  }
}