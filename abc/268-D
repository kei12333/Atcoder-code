268-D

ポイント
初めにSの文字列の順番を好きに変えるという文章やN<=8という文章からすぐに順列の並び替えば思い浮かぶだろう。あとはそれぞれの並びに対して再帰的な処理を行えばよい。
ここで気を付けることは、'_'がどれぐらい後ろにくっつくかということである。
一つの文字列の後ろに1個以上くっつく可能性があるので、'_'の残り後ろに着けられる数を数える必要がある。
これは簡単に求められremain=16-sum(s.size())-(n-1)である。あとは、dfsで後ろのつけるときとつけないとき両方再帰すればよい。
Sの後ろには最後以外必ず'_'は一個つけることに注意する。

#include<iostream>
#include<vector>
#include<algorithm>
using namespace std;

void dfs(int cur,vector<string> &S,vector<string> &T,int remain,string ans){
  if(remain<0) return;
  if(cur==(int)S.size()){
    if((int)ans.size()>=3&&!binary_search(T.begin(),T.end(),ans)){
      cout<<ans<<endl;
      exit(0);
    }
    return;
  }
  if((int)ans.size()>0&&ans.back()!='_') dfs(cur,S,T,remain,ans+'_');//ここで必ず後ろに着ける処理を行う。
  else{
    dfs(cur+1,S,T,remain,ans+S[cur]);
    if((int)ans.size()>0) dfs(cur,S,T,remain-1,ans+'_');
  }
}
int main(){
  int n,m;
  cin>>n>>m;
  vector<string> s(n),t(m);
  int tmp=0;
  for(int i=0;i<n;i++){
    cin>>s[i];
    tmp+=(int)s[i].size();
  }
  int r=16-tmp-(n-1);
  for(int i=0;i<m;i++) cin>>t[i];
  sort(s.begin(),s.end());
  sort(t.begin(),t.end());
  do{
    dfs(0,s,t,r,"");
  }while(next_permutation(s.begin(),s.end()));
  cout<<-1<<endl;
}
