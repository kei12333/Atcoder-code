270-D

ポイント
この問題はD問題にしては難しい。与えられてる例題はすべて貪欲法で解けるが実際は貪欲法では解けない。例としてはa[]={1,19,20}でn=58の時を考えてみよう。
もし貪欲法で解くと初め高橋君は20をとる。次に青木君も20をとるとのこり18となるので高橋君は合計で29となる。
しかし、もし高橋君が初めに19をとると青木君は次20をとったとしても19をとることができ38となるのでこちらのほうが大きい値となる。
よって貪欲法は使えない。よって全探索をする必要がある。
ここで思いつくのが動的計画法だ。この方法によって少ないプログラムで求めることができる。ここで、初めに方針を説明する。
高橋君が最大になればいいので青木君は高橋君が最小になるようにとっていけばよい。
また、石の数が0このとき１個の時....nこの時高橋君がどれぐらい石をとることができるかを考えるために、dp[i][0]を高橋君のターン、
dp[i][1]を青木君のターンとしてそれぞれ高橋君がどれぐらい石をとることができるかをdpにいれていく。

i=0の時は両方0である
i>=1のとき、高橋君の場合の遷移の仕方としては、まず青木君の次が高橋君なのでdp[][1]から遷移することはわかる。また、今とれる石がa[0],a[1]...a[k]なので石がi-a[k]からiに遷移することが分かる。よってdp[i-a[0]][1]......dp[i-a[k-1][1]からdp[i][0]にそれぞれ高橋君が取れる石の数a[k]を足して最大値をとったものにすればよい。
青木君の場合はこちらも同じように高橋君の次なのでdp[][0]から遷移することが分かる。また、dpに入れるのが高橋君の石の数ということに注意すると、高橋君の石の数を最小化するためにはdp[i-a[k]][0]の最小値をとり、dpに入れればよい。理由としては青木君がa[k]個とれば残りはi-a[k]個となり、高橋君がとる石はdp[i-a[k]][0]の時と状況が同じだからである。




#include<iostream>
#include<vector>
using namespace std;
int main(){
  int n,k;
  cin>>n>>k;
  vector<int> a(k);
  for(int i=0;i<k;i++) cin>>a[i];
  vector<vector<int>> dp(n+1,vector<int>(2,0));
  for(int i=0;i<=n;i++) dp[i][1]=1e9;
  dp[0][1]=0;
  for(int i=1;i<=n;i++){
    for(int j=0;j<k;j++){
      if(i-a[j]>=0) dp[i][0]=max(dp[i-a[j]][1]+a[j],dp[i][0]);
      if(i-a[j]>=0) dp[i][1]=min(dp[i-a[j]][0],dp[i][1]);
    }
  }
  cout<<dp[n][0]<<endl;
}