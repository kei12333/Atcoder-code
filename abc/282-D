282-D

ポイント
この問題は二部グラフの作り方を知っているか動画である。もし全成分が連結の場合を考えよう。その場合は適当にある頂点の値を0と決めて、そこからBFSを行い、隣り合う辺が交互に0か1にすることができれば二部グラフである。この場合は、0の個数×1の個数を求め、そこから変の数Mを引き算すれば求めることができる。
ただし、今回の問題では、連結成分ではないものも含まれている。この場合はどうするかというと、単純に二つのグラフに含まれている頂点の個数を掛け算すればよい。理由としては、異なる連結成分化では、二部グラフの頂点を反転しても問題ないのですべての頂点に線をつなぐことができるからだ。この考えを元にコードを書いていく

#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int main(){
  int n,m;
  cin>>n>>m;
  vector<int> g[200009];
  for(int i=0;i<m;i++){
    int u,v;
    cin>>u>>v;
    g[u].push_back(v);
    g[v].push_back(u);
  }

  vector<int> visited(n+1,-1);
  bool ok=true;

  vector<long long> compsz;      // 成分サイズ
  long long intra = 0;           // 各成分内の c0*c1 の総和

  for(int k=1;k<=n;k++){
    if(visited[k]!=-1) continue;

    // ★ 成分ごとのカウント
    long long cnt0 = 0, cnt1 = 0;

    queue<pair<int,int>> q;
    q.push({k,0});
    visited[k]=0;

    while(q.size()){
      auto [to,c]=q.front();
      q.pop();
      if(c==0) cnt0++;
      else cnt1++;

      for(int nex: g[to]){
        if(visited[nex]==-1){
          visited[nex] = c^1;
          q.push({nex, c^1});
        } else {
          if(visited[nex]==c) ok=false;
        }
      }
    }

    // 成分情報を保存
    compsz.push_back(cnt0 + cnt1);
    intra += cnt0 * cnt1;
  }

  if(!ok){
    cout << 0 << endl;
    return 0;
  }

  // ★ 成分間の組み合わせを累積で計算
  long long ans = intra;
  long long sum = 0;
  for(long long s : compsz){
    ans += sum * s;
    sum += s;
  }

  // 既存の辺は除く
  ans -= m;

  cout << ans << endl;
}
