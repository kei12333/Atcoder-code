265-D

ポイント
この問題は一見するとx,y,z,wが全部動くように見えるが、一か所固定化すれば簡単に解ける。初めにxの位置を固定化すれば累積和とlower_boundを使うことにより自動的に求まる。
例えば累積和sを求めておいて、xを全探索する。あるxにおいてs[y-1]-s[x]=pなのでp+s[x]があるかどうかをlower_boundで探せばよい。このことからyが決まる。これはzにもwにも言える。


#include<iostream>
#include<vector>
#include<queue>
using namespace std;
int main(){
  int h,w;
  cin>>h>>w;
  vector<string> g(h);
  for(int i=0;i<h;i++) cin>>g[i];
  queue<pair<int,int>> q;
  q.push({0,0});
  vector<vector<bool>> visited(h,vector<bool>(w,false)); 
  while(q.size()){
    auto [x,y]=q.front();
    if(visited[x][y]==true){
      cout<<-1;
      return 0;
    }
    visited[x][y]=true;
    q.pop();
    if(g[x][y]=='U'&&x-1>=0) q.push({x-1,y});
    else if(g[x][y]=='D'&&x+1<h) q.push({x+1,y});
    else if(g[x][y]=='R'&&y+1<w) q.push({x,y+1});
    else if(g[x][y]=='L'&&y-1>=0) q.push({x,y-1});
    else{
      cout<<x+1<<" "<<y+1<<endl;
      return 0;
    }
  }
}